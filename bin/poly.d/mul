#!/bin/sh
# poly*
# Multiply two polynomials over GF(2), each a residue of the CRC32
# polynomial.
# Each input polynomial should be a list of small integers, space
# separated, one polynomial per argument; typically this will require
# quotes.  Each list should be sorted into numerically increasing order.

product () {
    cumprod "" "$1" "$2"
}

# Takes 3 polynomials, one per argument.
cumprod () {
    # Return $1 + $2*$3
    if [ -z "$2" ] || [ -z "$3" ] ; then
        echo "$1"
        return
    fi
    if hasunit $2 ; then
        cumprod "$(add "$1" "$3")" "$(divx $2)" "$(mulx $3)"
        return
    fi
    cumprod "$1" "$(divx $2)" "$(mulx $3)"
}

# Takes 2 polynomials, one per argument.
add () {
    # The polynomial sum of $1 and $2.
    # Recall that in GF(2), 1+1=0, hence we combine all supplied
    # exponents and eliminate duplicates.
    echo $(
      for p in $1 $2; do echo "$p"; done | sort | uniq -c | 
        awk '$1 == 1 {print $2}' )
}

# Takes one polynomial, each exponent as a separate argument.
divx () {
    # Divide the polynomial by x, reducing all exponents by 1.
    # Any unit term is discarded.
    if [ "$1" -eq 0 ] ; then
        shift
    fi
    echo $(for p in "$@"; do echo $(($p - 1)); done)
}

# Takes one polynomial, each exponent as a separate argument.
mulx () {
    # Multiply the polynomial by x, increasing all exponents by 1.
    # :todo: Take remainder on division by the quotient polynomial.
    echo $(for p in "$@"; do echo $(($p + 1)); done)
}

# Takes one polynomial, each exponent as a separate argument.
hasunit () {
    # true when the polynomial has a non-zero unit term; false otherwise.
    [ "$1" -eq 0 ]
}

Test () {
    # Run the unittests.
    hasunit 0 7 33 || die
    ! hasunit 2 5 7 || die
    ! hasunit $(mulx 0 4 9) || die
    hasunit $(divx 0 1 8) || die
    ! hasunit $(divx 0 2 6) || die
    [ "$(mulx 2 13)" = "3 14" ] || die
    [ "$(divx 0 1 14)" = "0 13" ] || die

    [ "$(add "0 1 2" "1 2 3")" = "0 3" ] || die
    [ "$(cumprod '' "0 1 2" "0 1 2")" = "0 2 4" ] || die
    [ "$(product "1 2 3" "0 2 4")" = "1 2 4 6 7" ] || die
}

Main () {
    product "$@"
}

[ -n "$SHTEST" ] || Main "$@"
